###############################################################################################
###   第一课，进阶高手的大门

	1.数据结构是相互之间存在一定或多种特定关系的数据集合
	
	2.程序 = 数据结构 + 算法
	
	3.算法是程序的灵魂，好的算法会显著的提高程序的运算效率
	
	
###############################################################################################
###   第二课，数据的艺术
	
	1.数据 - 程序的操作对象，用于描述客观事物
	
	2.数据的特点：
		可以输入到计算机
		可以被计算机程序当做参数处理
		
		数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int,float,char等等
	
	3.数据元素 - 组成数据的基本单位
		数据项：一个数据元素由若干数据项组成
		
	4.数据对象 - 性质相同的数据元素的集合
	
	5.示例
		struct Student			------数据类型
		{
			char* name;
			int age;
		};
		
		struct Student s;		------数据元素
		
		struct Student stu[100];------数据对象
		
		s.name = "tom";			------数据项
		s.age = 30;
		
	6.数据元素之间不是独立的，存在特定的关系，这些关系即是结构。数据结构指数据对象中数据元素之间的关系
	
	7.数据结构中常见的数据关系 - 逻辑结构
		集合结构
			数据元素之间没有特别的关系，仅属于相同集合
		
		线性结构
			数据元素之间是一对一的关系，如数组
			
		树形结构
			数据元素之间存在一对多的层次关系，如树
			
		图形结构
			数据元素之间是多对多的关系，如图
			
	8.计算机中数据的实际存储方式 - 物理结构
		物理结构
			逻辑结构在计算机中的存储形式
			
		顺序存储结构
			将数据存储在地址连续的存储单元里面
		
		链式存储结构
			将数据存储在任意的存储单元里面，通过保存地址的方式找到相关联的数据元素
			
			
###############################################################################################
###   第三课，程序的灵魂-算法
	
	1.数据结构与算法
		数据结构只是静态的描述了数据元素之间的关系
		高效的程序需要在数据结构的基础上设计和选择算法
		
		高效的程序 = 恰当的数据结构 + 合适的算法
		
	2.算法是特定问题求解步骤的描述，在计算机中表示为指令的有限序列
	
	3.算法是独立存在的一种解决问题的方法和思想
	
	4.对于算法而言，语言并不重要，重要的是思想
	
	5.算法的五大特性
		输入	 -- 算法具有0个或多个输入
		输出	 -- 算法具有1个或多个输出
		有穷性	 -- 算法在有限的步骤之后会自动结束而不会无限循环
		确定性	 -- 算法中的每一步都有特定的含义，不会出现二义性
		可行性 	 -- 算法的每一步都是可行的
		
	6.算法的设计准则
		正确性
			算法对于合法数据能够得到满足要求的结果
			算法能够处理非法输入，并得到合理的结果
			算法对于边界数据和压力数据都能得到满足要求的结果
		
		可读性
			算法需要方便阅读，理解和交流
			
		健壮性
			算法不应该产生莫名其妙的结果
			
		高性价比
			利用最少的时间和资源得到满足要求的结果

			
###############################################################################################
###   第四课，审判数据的灵魂

	1.算法效率的度量
		●事后统计法
			比较不同算法对同一组输入数据的运行处理时间
			
			缺陷
				为了获得不同算法的运行时间必须编写相应的程序
				运行时间严重依赖硬件以及运行时间的环境因素
				算法的测试数据的选取比较困难
			
		综上所诉：事后统计法虽然直观，但是实施困难且缺陷多，一般不予考虑
		
		●事前分析估算法
			依据统计的方法对算法效率进行估算
			
			影响算法的主要因素
				算法采用的策略和方法
				问题的输入规模
				编译器所产生的代码
				计算机执行速度
		
	2.
	

###############################################################################################
###   第五课，线性表的本质
	
	1.线性表的定义
		线性表是零个或多个数据元素的集合
		线性表中的数据元素之间是有序的
		线性表中的数据元素个数是有限的
		线性表中的数据元素的类型必须相同
		
	2.线性表在程序中的定义
		线性表是具有相同类型的n(n>=0)个数据元素的有限序列
			(a1,a2,a3,....,an)
			ai是表项，n是线性表的长度
			
	3.线性表的性质
		线性表的第一个元素，没有前驱只有一个后继
		线性表的最后一个元素，没有后继只有一个前驱
		除了第一个元素和最后一个元素之外，其它的元素既有前驱又有后继
		线性表能够逐项访问和顺序存取
		

###############################################################################################
###   第六课，线性表的相关操作

	1.线性表相关的操作
		创建线性表
		销毁线性表
		清空线性表
		在线性表中插入元素
		将元素从线性表删除
		获取线性表中某个位置的元素
		获取线性表的长度
		
	2.线性表操作在C语言的实现
		线性表在程序中表现为一种特殊的数据类型
		线性表的操作在程序中表现为一组函数
		
			创建线性表:						List* List_Create();
			销毁线性表:						void List_Destory(List* list);
			清空线性表:						void List_Clear(List* list);
			在线性表中插入元素:				int List_Insert(List* list, ListNode* node, int pos);
			将元素从线性表删除:				ListNode* List_Delete(List* list, int pos);
			获取线性表中某个位置的元素:		ListNode* List_Get(List* list, int pos);
			获取线性表的长度:				int List_length(List* list);
			

###############################################################################################
###   第七课，线性表的顺序存储结构

	1.顺序存储定义
		线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素
		
	2.在C语言中可以使用一维数组来实现顺序存储结构
		存储空间起始位置：	数组node
		线性表的最大容量：	数组长度MAXSIZE
		线性表的当前长度：	length
		
			#define MAXSIZE 20
			
			typedef struct _tag_list
			{
				char node[MAXSIZE];
				int length;
			}List;
			
	3.获取元素操作
		判断线性表是否合法
		判断位置是否合法
		直接通过数组下标的方式获取元素
		
		char Get(List* list, int pos)
		{
			char ret = -1;
			
			//判断线性表是否合法以及位置是否合法
			if((list!= NULL) && (0 <=pos) && (pos < list->length))
			{
				ret = list->node[pos];
			}
				return ret;
		}
		
	4.插入元素操作
		判断线性表是否合法
		判断插入位置是否合法
		把最后一个元素到插入位置的元素后移一个位置
		将新元素插入
		线性表长度加1
		
		int Insert(List* list, char c, int pos)
		{
			//判断线性表是否合法
			int ret = (list != NULL);
			int i = 0;
			
			//判断插入位置是否合法
			ret = ret && (list->length+1 <= MAXSIZE);
			ret = ret && (0 <= pos);
			
			if (ret)
			{
				if (pos >= list->length)
				{
					pos = list->length;
				}
				
				//从最后一个元素开始到第pos个位置，分别将他们向后移动一个位置
				for(i=list->length; i>pos; i--)
				{
					list->node[i] = list->node[i-1];
				}
				
				//将新元素插入
				list->node[i] = c;
				
				//长度加1
				list->length++;
			}
			return ret;
		}
		
	5.删除元素操作
		判断线性表是否合法
		判断删除位置是否合法
		将元素取出
		将删除位置pos后的元素分别向前移动一个位置
		线性表长度减1
		
		char Delete(List* list, int pos)
		{
			char ret = -1;
			int i = 0;
			
			//判断线性表是否合法以及删除位置是否合法
			if((list != NULL) && (0 <= pos) && (pos < list->length))
			{
				//取出元素
				ret = list->node[pos];
				
				//把元素位置pos后的元素分别向前移动一个位置
				for(int i = pos+1; i<list->length; i++)
				{
					list->node[i-1] = list->node[i];
				}
				
				//长度减1
				list->length--;
			}
			return ret;
		}
	
	6.顺序表总结
		优点
			无需为线性表中的逻辑关系增加额外的空间
			可以快速的获取表中合法位置的元素
		
		缺点
			插入和删除操作需要移动大量元素
			当线性表变化较大时，难以确定其存储空间的容量
	
	
###############################################################################################
###   第八课，线性表的链式存储结构

	1.链表的基本概念
		表头节点：
			链表中的第一个节点，包含指向第一个数据元素的指针地址以及链表自身的一些信息
			
		数据节点：
			链表中代表数据元素的节点，包含指向下一个数据元素的指针和数据元素信息
			
		尾节点：
			链表中的最后一个数据节点，其下一个元素指针为空，表示无后继
			
	2.单链表实例
		头结点（线性表长度等公共数据，头指针） -- 节点a1（数据信息，下一个节点地址） --  ... --尾节点an（数据信息，NULL）
		
	3.链式存储结构
		在C语言中可以使用结构体来定义链表中的指针域，链表中的表头节点也可以使用结构体来实现
		
		结构体指针域的定义
			typedef struct _tag_ListListNode LinkListNode;
			
			struct _tag_LinkListNode
			{
				LinkListNode* next;
			};
			
		头结点的定义
			typedef struct _tag_LinkList
			{
				LinkListNode header;//头结点的信息
				int length;
			}TLinkList;
			
		数据元素的定义
			struct Value
			{
				LinkListNode header;
				int v;
			};
	
	4.获取元素操作
		判断线性表是否合法
		判断位置是否合法
		由表头开始通过next指针移动pos次后，当前元素的next指纹即指向要获取的元素
		
			LinkListNode* current = (LinkListNode*)List;
			
			for(i=0; i<pos; i++)
			{
				current = current->next;
			}
			ret = current->next;
		
	5.插入元素的操作
		判断线性表是否合法
		判断要插入的位置是否合法
		由表头开始通过next指纹移动pos次后，当前元素的next指针即是指向要插入的位置
		将新元素插入
		线性表长度加1
		
			LinkListNode current = (LinkListNode*)list;
			
			for(i=0; (i<pos) && (current->next != NULL); i++)
			{
				current = current->next;
			}
			
			node->next = current->next;
			current->next = node;
			
			sList->length++;
			
	6.删除元素操作
		判断线性表是否合法
		判断删除位置是否合法
		获取第pos个元素
		将这个元素从链表中删除
		线性表长度减1
		
			TLinkList* sList = (TLinkList*)list;
			LinkListNode* ret = NULL;
			int i = 0;
			
			if ((sList != NULL) && (0 <= pos) && (pos < sList->length))
			{
				LinkListNode* current = (LinkListNode*)list;
				
				for(i=0; i<pos; i++)
				{
					current = current->next;
				}
				
				ret = current->next;
				current->next = ret->next;
				
				free(ret);
				
				sList->length--;
			}
		
	7.链表的优缺点
		优点
			不需要一次性的定制链表的容量
			插入和删除不需要移动数据元素
		
		缺点
			数据元素必须保存后继元素信息
			获取指定数据的元素操作不需要顺序访问之前的元素

		
	
			
		

		
		
			
	
		

			
			
		

	
	
			
			
			
			
			
			
			
			
			
	
	
	
	
	
	
	
	
			
		
		
		
		
		
		
		
		
		
		
		