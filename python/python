##########################################################################################
### python 编译  

python编译的三种方式
	1.当作脚本使用，python test.py。或者chmod +x test.py赋予可执行权限后./test.py执行
	2.编译为python pyc文件执行，这种执行方式比脚本执行的速度快，具体使用方式
		新建一个python文件，内容如下
			import py_complie
			py_complie.complie('test.py')
	3.在命令行执行命令编译为pyo文件，命令如下：
		python -O -m py_compile test.py

##########################################################################################
### python 变量

1.变量的实际含义：
	变量是计算机内存中的一块区域，变量可以存储规定范围内的值，而且值是可以改变的,变量名就是计算机内存的一个别名。
2.python中的变量命名规则：
	--变量名中有字母、数字、下划线组成
	--不能以数字开头
	--不可以使用python中的关键字
3.python变量定义和赋值：
	python中变量不用定义，直接赋值使用
		a = 1
		a_2 = 2
4.python中使用id函数产看地址空间
	id(a),id(b)

##########################################################################################
### python 运算符与表达式

1.算术运算符
	--加法运算符：		x+y
	--减法运算符：		x-y
	--乘法运算符：		x*y
	--实数除法运算符：	x/y
	--整数除法运算符：	x//y	5.6/2=2.8  5.6//2=2.0
	--求余运算符：		x%y
	--求幂运算符：		x**y	2**3=8

2.赋值运算符
	--等于		：		x=3,y="wqing"
	--加等于	：		x+=2
	--减等于	：		x-=2
	--乘等于	：		x*=2
	--除等于	：		x/=2
	--求余等于	：		x%=2

3.关系运算符
	--小于		：		1<2
	--大于		：		2>1
	--小于等于	：		1<=2
	--大于等于	：		2>=1
	--不等于	：		1!=2
	--完全等于	：		1==1	

4.逻辑运算符
	--逻辑与	：		True and False
	--逻辑或	：		True or False
	--逻辑非	：		not True

5.运算符优先级
	# 	匿名函数：		lambda
	# 	逻辑运算：		or
	# 	逻辑运算：		and
	# 	逻辑运算：		not
	# 	成员测试：		in, not in
	# 	同一性测试：	is, is not
	由 	比较运算：		<, <=, >, >=, !=, ==
	低 	按位或：		|
	到 	按位异或：		^
	高 	按位与：		&
	# 	移位运算：		<<, >>
	# 	加减法：		+,-
	# 	乘除取余：		*, /, %
	# 	正负号：		+x, -x
	# 	按位反转：		~x
	# 	指数运算：		**

##########################################################################################
### python 数据类型

1.数字
	--整形	：	int
		取值范围：-2147483648~2147483647

	--长整形：	long
		取值范围：任意大小，末尾由大写的L或者是小写的l标注

	--浮点型：	float
		小数类型：0.4 

	--复数类型：complex
		以j结尾表示复数，2.14j
		
2.字符串
	--定义字符串可以用单引号，双引号，三引号来定义字符串
		str1 = 'wqing'
		str2 = "wqing"
		str3 = '''wqing'''

	--字符串切片
		str1 = 'wqing'
			说明，[a:b]:	从索引为第a个开始，包含a但是不包含b，数字是可选的，冒号是必须的

		str1[1:4] : qin		索引1——3的字符
		str1[:4}  : wqin	索引重头开始，不包含第四个
		str1[4:]  : g		索引第四个开始，到最后
		str1[::1] : wqing   设置步长值为1,一步一取值
		str1[::2] : wig		设置步长值为2,两步一取值	
		str1[-1]  : g		表示取字符串的最后一个字符
		str1[::-1]: gniqw	步长为-1表示倒着取字符串，::表示全取

3.列表
	1.list是处理一组有序项目的数据结构，列表的元素可以是任意的类型，数字-字符串-元组-列表都可以做为list的元素
	2.列表是可变类型的数据
	3.列表用[]表示列表
	4.列表定义方式：list1 = ['wqing',18,'woman']
	5.列表支持切片操作，操作方法如下
		--取值：通过切片和索引
		--添加：list.append()
		--删除：del(list[])或list.remove(list[])
		--修改：list[] = x
		--查找：var in list

4.元组
	1.元组和列表很相似，列表是用[]，元组是用(),列表的值可以变，元组的值不可以变
	2.定义方式：tup = ('wqing',30,'woman')
	3.元组同样可以使用切片取元素
	4.只有一个值的元组定义方式：
		tup = ('wqing',)
	5.空元组由一对空的括号组成
		tup = ()

5.字典
	1.字典是python中唯一的映射类型，存储方式为hash表
	2.字典对象是可变的，但是字典的键必须使用不可变的对象，并且一个字典可以使用不同类型的键值
	3.字典常用的方法：
		--keys()返回键列表
		--values()返回值列表
		--items()返回包含键值对的元组
	4.定义字典的方法：
		dic = {0:0, 1:1, 2:2}
		dic = {'name':'wqing', 'age':18, 'gender':'woman'}
		a = 123,dic = {a:'wqing', 'age':18, 'gender':'woman'}	可以使用变量a作为字典的key
	5.取值方式，通过前面的key取值
		dic['name']
	6.生成字典的其它方式：
		--工厂方法：
			dic = dict(['x',1],['y',2])	等同于 dic = {'x':1,'y':2}
		--内建方法fromkeys()：
			dic = {}.formkeys(('x','y'),-1)	这样子生成的字典元素值相同，如果不指定值，默认值为None
	7.字典增加值
		dic = {'name':'wqing', 'age':18, 'gender':'woman'}
		dic['tel'] = '12345678900'	这样就把值给增加进去了 
	8.更新和删除
		--update()方法可以将整个字典拷贝到另一个字典中
		--dic.pop('name')删除并返回键值为'a'的元素
		--del dic['a']删除字典中键值为'a'的元素
		--dic.clear()删除字典中的所有元素
		--del dic删除整个字典
		--dic.get(key)取字典中的值，如果不存在，返回空或者是任意值

6.序列
	1.序列是字符串，列表，元组的统称
	2.序列的基本操作如下：
		--len()			：	求序列的长度
		--+				：	连接两个序列
		--×				：	重复序列中的元素
		--in			：	判断元素是否在序列中
		--not in		：	判断字符是否不在序列中
		--max()		 	：	返回最大的值
		--min()			：	返回最小的值
		--cmp(str1,str2)：	比较两个序列的值是否相同，返回值：大于1,小于-1,等于0

##########################################################################################
### python 流程控制

1.流程控制 条件判断if
	1.Python中的if语句类似其他语言，if语句包含一个逻辑表达式使用表达式比较，在比较结果上做出决定
	2.基本格式：
		--if expression:	冒号作为if代码段开始的标记
			statement(s)
	3.python使用缩进作为语句分组的方法，建议使用四个空格作为缩进
	4.if条件语句的设置
		--逻辑值(bool)用来表示诸如：对与错，真与假，空与非空的概念
		--逻辑值包含了两个值：
			True：表示非空量(比如：string, tuple, list, set, dict等)
			False：表示0，None，空的量
		--作用：主要用于判断语句中，用来判断
			一个字符串是否为空
			一个运算结果是否是零
			一个表达式是否可用
	5.if--else语句	当条件不成立的时候执行else语句的内容
		if expression:
			statement(s1)
		else:
			statement(s2)
	6.if -- elif ... --else语句		elif语句可以让你检查多个表达式为真值，并执行一个代码块，elif是可选的
		if expression:
			statement(s1)
		elif expression2:
			statement(s2)
		........
		else:
			statement(sn)
	7.if语句嵌套
		if expression:
			if expression:
				statement(s1)
		else:
			statement(s2)

2.流程控制 逻辑 and or not
	--and 逻辑与	条件都为真返回真
	--or  逻辑或	条件有一个为真返回真
	--not 逻辑非	取反操作，not True:False  not False:True

3.流程控制 for循环
	1.在Python中for循环用来遍历序列，如一个列表或一个字符串
	2.for循环语法：
		for interating_var in sequence:
			statement(s)
		interating_var是一个迭代变量，每次从后面去取一个值，直到最后结束
	2.for循环配合else使用：	当for循环正常结束的时候可以执行else语句
		for var in list:
			print var
		else:
			print "for ending"

4.流程控制 遍历字典及序列
	1.遍历序列：
		for var in list:
			print var
	2.遍历字典：
		d = {1:"wqing",2:"ysqi"}
		for var in d:		仅仅是遍历K
			print d[var]
		
		for k,v in d.items():	key 和value一起遍历，要使用items函数转换成元组
			print k
			print v

5.流程控制 循环控制
	1.break：跳出循环
	2.continue：跳出本次循环
	3.pass：占位符
	4.return：结束整个代码
	5.exit()：跳出整个代码
	6.与for语句一起使用
		for var in list:
			if var ==1:
				print  "var ==1"
				continue
			if var == 3:
				print "var ==3"
				break
			if var == 4:
				pass	当var的值为4的时候，什么都不做
			if var == 5:
				return	结束整个代码
			if var == 6:
				exit()

6.流程控制 while
	1.while循环用于知道结束条件但是不知道循环次数的情况
	2.while循环示例：
		while True:
			print "hello"
			x = raw_input("please input some worlds,q for quit")
			if x == "q" or x == '':
				break
	3.while循环和if循环一样，也提供了一个else
		--在while循环条件失败的时候，执行else
		--在循环不是正常结束的时候执行else
		
##########################################################################################
### python 函数

1.函数就是完成特定功能的一个语句组，这组语句可以作为一个单位使用，并且给他取一个名字
2. 函数定义方式：
	--def 函数名 (参数列表):
		函数体
	--def fun()
		print "hello world"
3.形式参数和实际参数
	--形式参数：
		在定义函数时函数名后面的圆括号中的变量名叫做形式参数，简称形参，def fun(a) a就是形式参数
	--实际参数：
		在调用函数时，函数名后面的括号中的变量名叫做实际参数，简称实参，fun(b)  b就是实际参数
	--默认参数：
		在定义函数的时候，指定形参是默认值：
			def fun(x,y=2):
				print x,y
		在使用默认参数的函数时，不传值会使用默认参数，传值的时候回覆盖默认值，使用实际参数调用函数
	--任意数据类型都可以作为函数的参数，实数、字符串、元组、列表、字典都是可以的
4.变量的作用域：
	--在Python中变量分为局部变量和全局变量：
		1.局部变量：在函数中定义的变量称为局部变量，这种变量的作用域为定义的函数内
		2.在一个文件顶部或者是任意函数外定义的变量称为全局变量，该变量的作用域为整个文件
	--局部变量的例子：
		def fun():
			a = 'wqing'
			print a
		print a			因为a是局部变量，所以a在函数外调用的时候会报错
	--全部变量的例子：
		a = 'wqing'
		def fun():
			print a
		print a			因为a是全局变量，所有a可以在函数外使用
5.函数的返回值：return
	--Python中每一个函数调用之后都会返回一个指定的值，函数在调用之后默认返回None
	--可以显示的指定函数的返回值，使用方法如下：
		def fun(a, b):
			reutrn a+b		显式的使用return返回函数执行的结果
	--函数在执行到return语句的时候，函数执行终止，不管后面还有没有语句，函数都会终止执行
		def fun(a, b):
			return a+b
			print a+b		这个print语句不会被打印出来，因为函数在上一句已经返回
6.函数的参数类型：
	--位置参数：
		位置参数就是一般定义的参数，在函数定义的时候指明的参数
			def fun(a,b):	a和b就是位置参数
				return a+b
	--默认参数：
		在函数定义的时候指明参数的默认值，这个参数就是默认参数
			def fun(a,b=2):
				return a+b
		在调用带有默认参数的函数时可以少传递一个参数，如上面函数的调用方法
			if __name__ = "__main__":
				temp = fun(1)
				print temp		temp的值打印出来为3,因为第二个参数默认值为2
		在定义带有默认参数的函数时，要注意把默认参数放到参数列表的最后面，这样可以减少调用函数的难度
			--默认参数在参数列表的前面：
				def fun(a=2,b):
					retrun a+b
				if __name__ == "__main__":
					temp = fun(1)	这样子调用函数会直接报错，因为按照先后顺序参数会把1赋值给a，这时候b没有赋值，会报少一个参数的异常
					print temp

				if __name__ == "__main__":
					temp = fun(b=1)	这样子调用不会报错，但是要显示的指名1的值是传递给b形式参数的，a仍然使用默认参数作为参数的值
					print temp
			--默认参数在参数列表的后面：
				def fun(a,b=2):
					return a+b
				if __name__ == "__main__":
					temp = fun(1)	这样子调用在不指明1传递给哪个参数的情况下会默认的把1传递给a形式参数
					print temp
		--默认参数的内容一定是不可变的对象
			不可变对象如下：None,True,实数，具体声明的对象，元组，字典
	--可变参数：
		可变参数就是传递给函数的参数是可变的，可以是1个，2个到任意个，还可以是0个
			def fun(number):
				temp = 0
				for n in number:
					temp = temp + n
				return temp
		这样写的函数也可以传入多个参数，不过需要把参数先封装成列表或者是元组
			if __name__ == "__main__":
				list1 = [1,2,3,4,5,6,7]
				tmp = fun(list1)
				print tmp
		利用可变参数，可以简化封装成列表或者元组这一个步骤，修改fun函数定义如下：
			def fun(*number):
				temp = 0
				for n in number:
					temp = temp + n
				return temp
		主函数调用时可以直接传递进去多个参数：
			if __name__ == "__main__":
				tmp = fun(1,2,3,4,5,6,7)	这些参数在函数调用的时候自动封装成一个元组
				print tmp
		当已有已知的列表和元组的时候，可以把列表和元组当作可变参数传递给函数：
			if __name__ == "__main__":
				list1 = [1,2,3,4,5,6,7]
				tmp = fun(*list1)
				print tmp
	--关键字参数：
		可变参数允许传入0个或任意个数的参数，这些可变参数在函数调用时自动组装成一个元组，
		而关键字参数允许你传入0个或任意个数含关键字的参数，这些关键字参数在函数内部自动组装成一个字典
		
		包含关键字参数的函数的定义：
			def preson(name, age, **kw):
				print('name:', name, 'age:', age, 'other:', kw)
		在调用包含关键字参数的函数时，可以只传入必选参数name和age：
			if __name__ == "__main__":
				preson('wqing',18)
			输出结果为：
				name:wqing age:18 other:{}	可以看出，在没有传入关键字参数时，输出的是空的字典
		传入任意个数包含关键字的参数：
			if __name__ == "__main__":
				preson('wqing',18,city='zhengzhou')
			输出结果为:
				name:wqing age:18 other:{'city','zhengzhou'}	可以看出，传入的关键字参数被转换成了字典输出
		关键字函数的作用：
			除了必选参数外，可以给用户更多的选择，比如你在做一个信息录入系统，名字和年龄是必选项，地址等信息是可选项，可以考虑使用关键字参数
		怎么传入已知的字典作为带有关键子函数的参数：
			def preson(name, age, **kw):
				print('name:', name, 'age:', age, 'other:', kw)
			if __name__ == "__main__":
				dict = {'city':'zhengzhou','job':'test'}
				preson('wqing',18,**dict)
			输出结果为：
				name:wqing age:18 other:{'city':'zhengzhou','job':'test'}
	--命名关键字参数：
		上面说的关键字参数可以接受任意关键字的参数，以上面的preson()函数为例，如果只想接受的关键字为citt和job，这个时候就要使用命名关键字参数
			def preson(name, age, *, city, job): #和关键字参数××kw不同的是，命名关键字参数需要一个特殊的分隔符×，×后面的参数被视为命名关键字参数
				print(name, age, city, job)
			
			if __name__ == "__main":
				preson('wqing', age, city = 'zhengzhou', job = 'test')
			输出结果为：
				wqing 18 zhengzhou test
	--参数组合使用：
		在python函数中，可以使用必选参数，默认参数，可变参数，关键字参数和命名参数，这5中参数可以组合使用，但是使用必选参数的顺序必须是：
			必选参数--默认参数--可变参数--命名关键字参数--关键字参数
		定义一个函数，包含以上所有的参数：
			def fun(a,b,c=2,*d,e,**kw) #在有可变参数的时候，包含命名关键字参数的时候可以省略×
				print(a,b,c,d,e,kw)	
			
7.递归函数：
递归函数就是在函数的内部调用自己本身，这个函数就是递归函数。
--求n的阶乘的递归函数的定义：	
	def fun(n):
		if n == 1:
			return 1
		return n*fun(n-1)
	
	if __name__ == "__main__":
		fun(5)
	函数执行过程如下：
		===> fact(5)
		===> 5 * fact(4)
		===> 5 * (4 * fact(3))
		===> 5 * (4 * (3 * fact(2)))
		===> 5 * (4 * (3 * (2 * fact(1))))
		===> 5 * (4 * (3 * (2 * 1)))
		===> 5 * (4 * (3 * 2))
		===> 5 * (4 * 6)
		===> 5 * 24
		===> 120
--使用递归函数的时候要注意防止栈溢出，每进入一个函数调用，栈就会增加一层栈帧，每当函数返回，栈就会减少一层栈帧，所以函数调用次数大的时候会导致栈溢出
--尾递归的方法可以解决栈溢出现象，尾递归是指在函数返回的时候调用自己本身，并且ruturn语句中不能包含表达式，这样递归本身无论调用多少次，都占用一个栈帧
--尾递归函数的定义：
	def fun(n, tmp):
		if n == 1:
			return tmp	
		return fun(n-1,n*tmp)
	
	if __name__ == "__main__":
		fun(5,1)
	函数调用时执行过程如下：
		===> fact_iter(5, 1)
		===> fact_iter(4, 5)
		===> fact_iter(3, 20)
		===> fact_iter(2, 60)
		===> fact_iter(1, 120)
		===> 120
	可以看出尾递归可以减少函数栈空间的开销，但是python并没有对尾递归做优化，所以过大的调用也会导致栈溢出

8.函数式编程：
	--高阶函数：
		当一个函数名作为另一个函数的参数时，这种函数就称之为高阶函数
		定义一个高阶函数：
			def add(x,y,f):
				return f(x)+f(y)
		
		if __name__ == "__main__":
			tmp = add(-1,-2,abs)	#分别传如-1,-2和ads求绝对值函数
		程序运行结果：	
			ads(-1)+abs(-2) = 3
	--map()函数：
		map()函数是一个高阶函数，它会调用传入的函数隐式的处理list的每一个元素，并返回一个新的list
		map()函数使用示例：
			def f(x):
				return x*x
			if __name__ == "__main__":
				l = [1,2,3,4,5,6,7,8,9]
				r = map(f,l)
				print r
			程序运行的结果为:[1,4,9,16,25,36,49,64,81]
	--reduce()函数：
		reduce()把一个函数作用在一个序列上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，计算效果如下：
			reduce(fun,[x1,x2,x3,x4]) = fun(fun(fun(x1,x2),x3),x4)
		reduce使用示例：
			from functools import reduce
			def add(x,y):
				return x+y
			
			if __name__ == "__main__":
				reduce(add,[1,3,5,7,9])
			程序运行结果为:
				1+3+5+7+9 = 25
	--filter()函数：
		filter()函数也接收一个函数和一个序列，fliter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素
		fliter()函数使用示例：
			def is_odd(n):
				return n%2 == 1		#仅保留对2取余为1的数，也就是过滤掉偶数
			
			if __name__ == "__main__":
				list(filter(is_odd,[1,2,4,5,7,10]))
			函数执行结果：
				[1,5,7]
	--sorted()函数：
		sorted()函数本身就可以对序列进行排序，也可以接收一个key函数来实现自定义排序
		1.默认排序：
			sorted([24,-23,-45,2])
			结果：[-45,-23,2,24]
		2.指定排序函数进行排序：
			sorted([24,-23,-45,2],key=abs)
			结果：[2,-23,24,-45]
	--函数作为返回值：
		1.闭包：在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用，这样就构成了一个闭包，
				一般情况下函数在调用结束的时候就会把资源还给内存，但是闭包是一个特殊的情况，如果外函数在结束的时候发现自己的临时变量将来
				会在内部函数中用的到，就把这个临时变量绑定给内部函数，然后自己再结束。
		闭包函数示例：
			def fun(*args):
				def sum():
					ax = 0
					for i in args:
						ax = ax + n
					return ax
				return sum
			
			if __name__ == "__main__":
				f = fun(1)
				print f
			程序运行结果：<function sum at 0x7fecda81f6e0>,是内部函数的地址而不是结果，只有在执行的时候才会返回结果
			f()	#这次执行f，执行结果为：1
	--匿名函数：
		匿名函数的定义：
			lambda x: x*x 	# 等同于def fun(x) return x*x
		匿名函数只能有一个表达式，不用写return语句，返回值就是该表达式的结果
	--装饰器：
		
	--偏函数：
		
##########################################################################################
### python 模块


##########################################################################################
### python 面向对象编程





















