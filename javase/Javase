######################################################################
#####面向对象

1.面向对象思想
	面向对象是基于面向过程的编程思想。
	
	面向过程：强调的是每一个功能的步骤
	面向对象：强调的是对象，然后由对象去调用功能
	
2.面向对象的思想特点：
	A：是一种更符合我们思维习惯的思想
	B：可以将复杂的事情简单化
	C：将我们从执行者变成了指挥者
	D：万事万物皆对象
	
	举例：
		买电脑：
			面向过程：了解电脑--了解自己的需求--找对应的参数信息--去买电脑--讨价还价--买回电脑
			面向对象：我知道我要买电脑--小明去给我买个电脑--小明给我买回来了
			
3.把大象装进冰箱：
	面向过程：
		动作：
			A：打开冰箱门
			B：装进大象
			C：关闭冰箱门
			
		代码：
			class Demo{
				public static void main(String[] args){
					open();
					in();
					close();
				}
				public static void open(){
					System.out.println("打开冰箱门");
				}
				
				public static void in(){
					System.out.println("装进大象");
				}
				
				public static void close(){
					System.out.println("关闭冰箱门");
				}
			}
			
	面向对象：
		我们怎么才能更符合面向对象思想呢？
			A：有哪些类呢？
			B：每个类应该有哪些东西呢？
			C：类与类的直接关系是什么呢？
		
		把大象装进冰箱的分析：（如何分析有哪些类呢？UML，名词提取法）
			A：有哪些类呢？
				大象
				冰箱
				Demo
			B：每个类有哪些东西呢？
				大象：
					进去
				冰箱：
					开门
					关门
				Demo：
					main方法
			C：类与类直接关系是什么呢？
				Demo中使用大象和冰箱类的功能
		
		代码实现：
			class Elephant{
				public static void in(){
					System.out.println("装进大象");
				}
			}
			
			class Ice{
				public static void open(){
					System.out.println("打开冰箱门");
				}
				
				public static void close(){
					System.out.println("关闭冰箱门");
				}
			}
			
			class Demo{
				public static void main(String[] args){
					Ice.open();
					Elephant.in();
					Ice.close();
				}
			}
			
4.面向对象开发、设计、特征：
	面向对象开发：
		就是不断的创建对象，使用对象，指挥对象做事情
	
	面向对象设计：
		就是在管理和维护对象之间的关系
	
	面向对象特征：
		封装（encapsulation）
		继承（inheritance）
		多态（polymorphism）
		
5.现实世界中是如何描述一个事物的呢？
	举例：学生
		姓名，年龄，性别。。。
		学习，吃饭，睡觉
		
	属性：该事物的描述信息
	行为：该事物能做什么
	
	我们学习编程语言就是为了模拟现实世界的事物，而Java中最基本的单位是类，
	所以我们就要把事物通过类来体现出来，下面是现实世界事物和类的对应关系；
	
	事物：						类：
		属性						成员变量
		行为						成员方法
		
6.类和对象的定义
	类：是一组相关的属性和行为的集合
	对象：对象是该类事物的具体表现形式，具体存在的个体。
	
	举例：
		学生：类
		班长：对象

7.类的定义和使用：
	定义一个类就是定义该类的成员变量和成员方法。
	学生事务：
		属性：姓名，年龄，地址….
		行为：学习，吃饭，睡觉….
	转换成学生类：
		成员变量：姓名，年龄，地址
		成员方法：学习，吃饭，睡觉
	
	成员变量：在类中方法外的变量
	成员方法：和之前方法定义的格式一样
	
	用代码实现：
		//这是我的学生类
		Class Stusdent{
			//姓名
			String name;
			//年龄
			Int age;
			//地址
			String address;
		
			Public void study(){
				System.out.println(“学生学习”);
			}
			Public void eat(){
				System.out.println(“学生吃饭”);
			}
			Public void sleep(){
				System.out.println(“学生睡觉”);
			}
		}

8.对象的创建与使用：
	创建对象的方法：
		类名 对象名 = new 类名();
		
	使用对象：
		对象名.成员变量
		对象名.成员方法()
		
9.成员变量和局部变量的区别：
	A：在类中的位置不同
		成员变量：在类中方法外
		局部变量：在方法定义中或方法声明上
	B:内存中的位置不同
		成员变量：在堆内存
		局部变量：在栈内存
	C:声明周期不同
		成员变量：随对象的创建而存在，随对象的消失而消失
		局部变量：随方法调用而存在，方法调用完毕而消失
	D：初始化值不同
		成员变量：有默认初始化值
		局部变量：没有默认初始化值，必须声明，初始化使用（不初始化值会报错）
	E:注意事项
		局部变量名称可以和成员变量名称一样，在方法使用的时候，采用就近原则
		
10.形参的传递问题：
	基本类型：形式参数的改变不影响实际参数
	引用类型：形式参数的改变直接影响实际参数（方法的参数是对象）

11.匿名对象：没有名字的对象
	A：带名字的对象：
		Student s = new Student();
	B:匿名对象：
		new Student();
	C:匿名对象的使用场景：
		1.仅仅只调用一次的时候，好处是匿名对象调用完毕后就是垃圾，可以直接被垃圾回收机制回收
		2.匿名对象可以做实际参数传递
		
12.封装的概述：
	A:封装是指隐藏对象的属性和细节，仅仅对外提供公共的访问方式
	
	B:关键字：private
		private，私有的，可以用来修饰成员变量和成员方法，被private修饰的成员只能通过本类中的公共方法对其访问
		private修饰成员变量：
			通过本类的方法调用和访问
		private修饰成员方法：
			通过本类的方法调用和访问
		private关键字的应用：
			
	C：封装的好处
		1.隐藏实现细节，提供公共访问方式
		2.提高了代码的复用性
		3.提高安全性
		
	D:封装原则
		1.把不需要对外界提供的内容都对外隐藏起来
		2.把属性隐藏起来，提供公共方法对其访问
		
	E:private最常见的应用
		1.把成员变量用private修饰
		2.提供对应的getXxx()和setXxx()方法
		
	F:this关键字
		1.this关键字代表的是所在类的对象引用，简单的记，它就代表当前类的对象
		2.谁调用这个方法，在该方法内部的this就代表谁，避免了就近原则
		3.this随着对象的创建而存在
		4.this的使用场景：
			解决局部变量隐藏成员变量

13.构造方法：
	A:构造方法主要用于给对象的数据进行初始化
	B:格式
		1.方法名与类名相同
		2.没有返回值类型，连void都没有
		3.没有具体的返回值
	
	C:构造方法的注意事项“
		1.如果我们没有给出构造方法，系统会自动提供一个无参构造方法
		2.如果我们给出了构造方法，系统将不再提供默认的无参构造方法，这个时候如果还想使用无参构造方法，就要自己给出无参构造方法
		3.构造方法的重载格式：
			A:与普通的方法一样，方法名相同，参数列表不同（参数类型或者是参数个数不同）
			
14.类的组成：
	A:成员变量
		1.就近原则
		2.和类中的方法处于同一等级
	
	B:构造方法
		1.方法名和类名相同，没有返回值
		2.推荐永远给出无参构造方法，带参构造方法属于方法重载
	
	C:成员方法
		1.根据返回值分：void类型，非void类型
		2.根据形式参数分：空参方法，带参方法

15.创建对象的时候在内存中做了什么事
	Student s = new Student();
	
	A:加载Student.class文件进方法区
	
	B:在栈内存为s开辟空间
	
	C:在堆内存中为学生对象开辟空间
	
	D:对学生对象的成员变量进行默认初始化
	
	E:对学生对象的成员变量进行显示初始化
	
	F:通过构造方法对学生对象的成员变量进行赋值
	
	G:数据初始化完毕，把对象的地址赋值给s变量，变量指向堆内存
	
16.变量什么时候定义为成员变量
	如果这个变量是用来描述这个类的信息的，那么，该变量就应该定义为成员变量
	
	变量到底定义在哪里好？
		变量的定义范围是越小越好，因为能及时被回收
		
17.static关键字的用法
	A:static关键字的特点
		1.随着类的加载而加载
		2.优先于对象存在
		3.被类的所有对象共享
	
	B:什么时候使用静态修饰成员
		1.某个成员是被所有对象共享的，那么它应该被定义为静态
	
	C:静态成员的调用
		1.可以使用类名和对象名调用
		2.推荐使用类名调用，静态修饰的内容一般为--与类相关的或者是类成员
	
	D:静态在内存中的表示
		1.在方法区中有专门的静态区存储静态成员
		2.静态区随着类的加载而加载，是被该类的所有对象共享的
	
	E:使用静态的注意事项
		1.在静态方法中没有this关键字
			静态是随着类的加载而加载的，this是随着对象的创建而存在的
		2.静态方法只能访问静态成员方法以及静态成员变量
			由于静态比对象先存在，所以无法访问非静态成员
		3.非静态可以访问静态的成员
	
	F:静态方法的访问注意事项：静态只能访问静态，非静态可以访问一切
		1.静态：
			成员方法：只能访问静态非方法
			成员变量：只能访问静态变量
		2.非静态：
			成员变量以及成员方法均可以是静态或非静态
	
	G:静态变量和成员变量的区别
		1.所属不同
			静态变量属于类，所以也称为类变量
			成员变量属于对象，所以也称为实例变量
		2.内存中的位置不同
			静态变量存储于方法区的静态区
			成员变量存储于堆内存
		3.内存中出现的时间不同
			静态变量随着类的加载而加载，随着类的消失而消失
			成员变量随着对象的创建而存在，随着对象的消失而消失
		4.调用不同
			静态变量可以通过类名调用，也可以通过对象调用
			成员变量只能通过对象名调用
			
	F:main的格式
		public static void main (String[] args){...}
		
		1.public
			公共的访问权限，由于main方法是被JVM调用，所以权限是最大
		2.static
			静态的，不需要创建对象，可以通过类名直接调用，方便JVM调用
		3.void
			方法的返回值，main方法是被JVM调用，返回给JVM调用没有意义
		4.String [] args
			这是一个字符串数组，用于解析函数的传值，也就是说函数传入的参数是默认存在了String[] args 数组里面
			使用格式：
				java MainDemo hello world using java
				显示的调用JVM去传递参数

18.Java工具类的使用以及API文档使用方法
	A：在一个文件夹下建立两个文件去分别定义类跟在一个文件下定义两个类是一样的	

	B：在工具类中定义静态的方法，将构造方法私有化，外界只能通过类名去调用方法，不能创建对象
	
	C：如何制作一个说明文档
		1.写一个工具类
		2.在类中加文档注释
			/**
			*这是一个文档注释
			*@author ysq
			*version v1.0
			*/
		3.解析文档注释
			使用javadoc工具
			javadoc -d 目录 -author -version ArrayTool.java 
	
	D：如何使用帮助文档
		1.查看改类是在哪个包下，除了java.lang包下的类不用导入，其他的全部要导入
		2.看类的解释和说明以及该类的版本信息
		3.看类的结构
			成员变量	字段摘要
			构造方法	构造方法摘要
			成员方法	成员方法摘要
		4.学习构造方法
			有构造方法	创建对象
			无构造方法	成员可能都是静态的，通过类名调用
		5.学习成员方法
			A：看左边
				是否是静态？如果静态，可以通过类名调用
				返回值类型，返回值是什么类型，就用什么类型接收
			B：看右边
				看方法名
				看参数列表，参数个数和参数类型要对应

19.代码块
	A：什么是代码块？
		在Java中使用{}括起来的代码被称为代码块

	B：根据位置和声明不同，可以分为局部代码块，构造代码块，静态代码块和同步代码块
		1.局部代码块:在方法定义中的代码块
			作用：用于限定变量的声明周期（将变量生命周期限定在当前的大括号内），及早释放，提高内存使用率
		2.构造代码块：在类中的成员位置
			作用：用于将不同的构造方法的相同代码提取出来，每次调用构造方法都会执行构造代码块，再构造方法前执行
				  对对象进行初始化
		3.静态代码块：在类中的成员位置，用static修饰
			一般是对类进行初始化，静态代码块在类第一次加载的时候执行，只执行一次
		4.静态代码块，构造代码块，构造方法的执行顺序？
			静态代码块 -- 构造代码块 -- 构造方法
			静态代码块执行一次，构造代码块每次调用构造方法都执行
			
20.继承：
	1.继承的概述
		多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只需要继承那个类即可。
		
	2.继承的格式
		通过extends关键字可以实现类与类的继承
			class 子类名 extends 父类名{}
		单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类。
		有了继承之后，我们定义一个类的时候，可以在一个已经存在的类的基础上，还可以定义自己的新成员。
		
	3.继承的优劣
		A:优势
			1.提高代码的复用性
			2.提高代码的维护性
			3.让类与类产生了关系，是多态的前提
		B:劣势
			1.类的耦合性增强了（开发的原则，低耦合高内聚）
			
	4.Java中继承的特点
		A:Java中只继承单继承，不支持多继承（C++是支持多继承的）
			class Son extends Father,Mother{}
			
		B:Java中支持多层继承
			class Father extends GrandFather{}
			class Son extends Father{}
			Son的对象可以调用GrandFather的方法

	5.Java中继承的注意事项
				A:只能继承父类所有非私有成员（成员变量或成员方法）
		
		B:子类不能去继承父类的构造方法，但是可以通过super关键字去访问父类的构造方法
		
		C:不要为了部分功能而去使用继承
		
		D:什么时候使用继承呢？
			继承实际上体现的是 “is a”的关系，如果有两个类A和B，只要他们符合A是B的一种或者B是A的一种，就可以使用继承
		
	6.this关键字和super关键字的区别
		A:this关键字
			this代表的是本类对象的引用
			
		B:super代表父类的存储空间标识，可以理解为父类的引用，可以在子类中操作父类的成员
		
		C:使用方法
			1:调用成员变量
				this.成员变量 调用本类的成员变量
				super.成员变量 调用父类的成员变量
			
			2:调用构造方法
				this(...) 调用本类的构造方法
				super(...) 调用父类的构造方法
				
			3:调用成员方法
				this.成员方法 调用本类的成员方法
				super.成员方法 调用父类的成员方法
			
	7.继承中成员的关系
		A：成员变量
			1.子类中成员变量和父类中成员变量名称不一样，各使用各的
			2.子类中的成员变量和父类中的成员变量的名称一样，访问顺序如下：
				a.在子类方法的局部范围查找，有就使用
				b.在子类的成员范围查找，有就使用
				c.在父类的成员范围查找，有就使用
				d.如果还查找不到变量，就报错
				
		B：成员方法
			1.子类中的方法和父类的方法声明不一样，各使用各的
			2.子类中的方法和父类的方法声明一样
				a：先找子类中看有没有这个方法，如果有就使用，再看父类中有没有这个方法，如果没有就报错
		
		C：构造方法
			1.子类中的所有构造方法默认都会访问父类的无参构造方法
				因为子类会继承父类的数据，在子类初始化前，一定要先完成父类的初始化才能供子类使用
				即子类每一个构造方法的第一条语句默认都是：super()
				
			2.如果父类中没有无参构造方法，那么子类怎么去调用父类的构造方法去初始化父类的成员数据呢？
				a：在父类中加一个无参构造方法
				b：通过super关键字去显示的调用父类的带参构造方法
				c：在子类中通过this关键字去调用本类的其他构造方法
					子类中一定要有一个去访问了父类的构造方法，否则父类的数据就没有初始化
				d：this(...)和supper(...)调用构造方法必须放在第一条语句上
					如果不是放在第一条语句上，就可能对父类的数据进行多次初始化
					
	8.方法重写：
		A：什么是方法重写
			子类中出现了和父类中方法声明一模一样的方法
			注意与方法重载的区分：
				方法重载：本类中出现方法名一样，参数列表不同的方法，与返回值无关
		
		B：使用特点
			如果方法名不同，就调用对应的方法
			如果方法名相同，最终使用的是子类自己的
		
				C：方法重载的使用场景
			当子类需要使用父类的功能，而功能主体子类有自己特有的内容时，可以重写父类的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容
			使用方法如下：
				class Fu{
					public void call (String name){
						System.out.println("给"+name+"打电话");
					}
				}
				class Zi extends Fu{
					public void call (Strings name){
						super.call(name);
						System.out.println("可以看电影");
					}
				}
		
		D：方法重写注意事项
			1.父类中的私有方法不能被重写，因为父类私有方法子类根本就无法继承
			2.子类访问父类的方法时，访问权限不能更低，最好一致
			3.父类静态方法，子类也必须通过静态方法进行重写
			4.子类重写父类方法的时候，最好声明一模一样
			
	9.final关键字
		A：由于继承中有方法重写现象，所以父类的功能可能会在父类中重写，有的时候，我们不想让子类去覆盖掉父类的功能，只能让子类去使用
				针对这一情况，Java就提供了一个关键字：final
				
		B：final，最终的意思，常见的是它可以修饰类，方法和成员变量
		
		C：final关键字的特点
			1.final修饰类：
				被final修饰的类称为最终类，该类不能被继承
				
			2.final修饰方法：
				被final修饰的方法不能被重写
				
			3.final修饰变量：
				被final修饰的变量实际上为常亮，被final修饰的变量不能被重新赋值
				
		D：使用final关键字的注意事项
			1.final修饰局部变量
				final修饰引用类型的时候，因为引用类型是实际是栈内存的地址，所以地址不能变，但是地址中的值是可以发生改变的，类似于C语言的指针
				
			2.final修饰变量的初始化时机
				在构造方法完毕前（针对非静态）
	
21.多态
	1.什么是多态：
		某一个事物（对象），在不同时刻表现出来的不同状态
		例如：
			猫可以是毛的类型：Cat c = new Cat();
			同时猫也是动物的一种，也可以把猫称作为动物：Animal A = new Cat();
			
	2.多态的前提：
		A：要有继承关系
		
		B：要有方法重写
			其实没有也是可以的，但是如果没有就没有意义
			
		C：要有父类引用指向子类对象
			Fu f = new Zi();
			
	3.多态中的成员访问特点
		A：构造方法
			创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化
			
		B：成员变量
			编译看父类，运行看父类
			
		C：成员方法
			编译看父类，运行看子类（因为方法重写覆盖了父类的方法）
		
		D：静态方法
			编译看父类，运行看父类（因为静态方法和类相关，访问的还是父类的）
			
		E：由于成员方法存在方法重写，所以运行的时候是访问的子类重写过的方法
		
	4.多态的好处
		A：提高了代码的复用性（由多态保证）
		
		B：提高了代码的扩展性
		
	5.多态的弊端
		只能使用父类的已经定义的功能，不能使用子类特有功能
		
	6.多态中的向上转型
		A：向上转型
			Fu f = new Zi();
			
		B：向下转型
			Zi z = (Zi) f;
			
22.抽象类
	A：在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类
	
	B：抽象类的特点：
		1.抽象类必须用abstract关键字修饰
		
		2.抽象类不一定有抽象方法，但是有抽象方法的类一定要定义为抽象类
		
		3.抽象类有构造方法，但是不能被实例化，因为它不是具体的，构造方法的作用是用于子类访问父类的初始化
		
		4.抽象类的子类
			a：抽象类的子类是一个抽象类，可以不重写抽象类中的抽象方法
			
			b：抽象类的子类是一个具体类，重写抽象类中的所有抽象方法
			
		5.抽象类的实例化是靠具体子类实现的，是采用多态的方式进行实现的
			Animal a = new Cat();
			
	C：抽象类的成员特点
		1.成员变量
			既可以是变量，也可以是常量
			
		2.成员方法
			既可以是抽象的，也可以是非抽象的
			
		3.构造方法
			用于子类访问父类的初始化
		
		4.抽象类的成员方法特性
			a：抽象方法     强制要求子类做的事情
			b:非抽象类方法  子类继承的事情，提高代码复用性
			
	D：抽象类中的小问题
		1.一个类如果没有抽象方法，可不可以创建为抽象类？如果可以，有什么意义
			a：可以
			b：不让外界创建对象
			
		2.abstract关键字不能和哪些关键字共存
			a：private	私有不能被继承，抽象要求被继承，所以有冲突
			b：final		最终态不能被重写，抽象要求被继承，所以有冲突
			c：static	静态修饰的与类相关，可以直接通过类调用，由于抽象没有方法体，所以没有意义
			
23.接口
	A：为了体现事物的扩展性，java就提供了接口来定义额外的功能，并不给出具体的实现，将来哪些对象需要使用，将这些额外的功能实现即可
	
	B：接口使用interface来表示
		interface 接口名 {}
		
		interface AnmialTrain{
			public abstarct void jump();
		}
		
	C：类实现接口用implements表示
		class 类名 implements 接口名 {}
		
		class Cat implements AnmialTrain{
			public void jump(){
				System.out.println("....");
			}
		}
		
	D：接口只能通过多态的方式来实例化
	
	E：接口的子类
		1.可以是抽象，但是意义不大
		2.可以是抽象类，要重写接口中的所有抽象方法
	
	F：接口中的成员特点
		1.成员变量
				接口中的成员变量默认是最终变量，并且是静态的，默认修饰符为	public static fianl
			
		2.成员方法
				只能是抽象方法 默认修饰符是	public abstarct
		
		3.构造方法
				接口主要是功能扩展，而扩展是没有具体存在的
				
	G：类与类，类与接口，接口与接口的关系
		1.类与类
				继承关系，只能单继承，可以多层继承，但是不能多继承
				
		2.类与接口
				实现关系，可以单实现，也可以多实现，并且可以在实现继承一个类的同时实现接口
				
		3.接口与接口的关系
				继承关系，可以单继承，也可以多继承
				
				interface Father{}
				interface Mother{}
				interface Sister extends Father,Mother{}
				
	H：抽象类和接口的区别
		1.成员区别
			a:抽象类
				成员变量：可以变量，可以常量
				构造方法：有
				成员方法：可以抽象，可以非抽象
			b：接口
				成员变量：只可以常量
				成员方法：只可以抽象
				
		2.关系区别
			a：类与类：继承，单继承
			b：类与接口：实现，单实现，多实现
			c：接口与接口：继承，单继承，多继承
		
		3.设计理念不同
			a：抽象类：被继承体现的是“is a”的关系。抽象类中定义的是该继承体系的共性功能
			b：接口：被实现体现的是“like a”的关系。接口中定义的是该继承体系的扩展功能
			
24.类的构建方法
	A：示例：
		乒乓球运动员和篮球运动员
		乒乓球教练和篮球教练
		为了出国交流，跟乒乓球相关的人员都要学习英语
		
		1.分析事物重具体到抽象，慢慢寻找共性东西
		2.实现从具体到抽象
		3.使用具体的类
		
		4.示例分析结果：
																								人   （抽象类）（姓名，年龄，吃饭();睡觉(){})
											
											运动员（抽象类）（学习();)																								教练（抽象类）（教();）
											
					
					乒乓球运动员（具体类）      篮球运动员（具体类）													乒乓球教练（具体类）								篮球教练（具体类）
					
					
																									学习英语（接口）（学习口语();）

25.形式参数和返回值的问题
	A：形式参数：
		1.基本类型
		2.引用类型
			a：类：需要的是该类的对象
			b：抽象类：需要的是该抽象类的子类对象（通过多态）
			c：接口：需要的是该接口的实现类对象
			
	B：返回值类型：
		1.基本类型
		2.引用类型
			a.类：真正返回的是该类的对象
			b.抽象类：返回的是该抽象类的子类对象
			c.接口：返回的是该接口的实现类对象
			
26.链式编程
	每次调用完方法后，返回的是一个对象
	
27.包的概述
	A：包其实就是文件夹
	
	B：作用，把相同的类名放到不同的包中，对类进行分类管理
	
	C：包的定义
		package 包名;
		多级包用.分开
		
	D：注意事项
		package语句必须是程序的第一条可执行的代码
		package在一个java文件中只有一个
		如果没有package，默认表示无包名
		
	E：带包的类编译和运行
		javac 编译的时候带-d即可
			javac -d . HelloWorld.java
			
	F：不同包下的类之间的访问
		使用java的导包功能
			import com.java.ysq;					

28.四种权限修饰符
										本类					同一个包下（子类和无关类）				不同包下（子类）		不同包下（无关类）
		private					Y						
		默认						 Y						Y
		protected				Y						 Y																Y
		public					Y						 Y																Y									Y
		
		A:修饰符：
			权限修饰符：private，默认的，protected，public
			状态修饰符：static，final
			抽象修饰符：abstract
		
			a.类：
				权限修饰符：默认修饰符，public
				状态修饰符：final
				抽象修饰符：abstract
				
				用的最多的就是：public
				
			b.成员变量：
				权限修饰符：private，默认的，protected，public
				状态修饰符：static，final
				
				用的最多的就是：private
				
			c.构造方法：
				权限修饰符：private，默认的，protected，public
				
				用的最多的就是：public
				
			d.成员方法：
				权限修饰符：private，默认的，protected，public
				状态修饰符：static，final
				抽象修饰符：abstract
				
				用的最多的就是：public
				
			e.除此以外的组合规则：
				成员变量：public static final
				成员方法：public static 
				         public abstract
						  	 public final

29.内部类
	A：把类定义在其他类的内部，这个类就是内部类
		在类A中定义了一个类B，类B就是内部类
		
		class Outer{
			class Inner{
			
			}
		}
	
	B：内部类的访问特点
		1.内部类可以直接访问外部类的成员，包括私有
		2.外部类要访问内部类的成员，必须创建对象
		3.内部类和外部类没有继承关系
		
	C：内部类的位置
		1.在成员位置定义的类，被称为成员内部类
			a.访问方式：
				外部类名.内部类名 对象名 = 外部类对象.内部类对象；
				Outer.Inner oi = new Outer().new Inner();
				
			b.成员内部类的修饰符
				private 保证安全性
				static 为了让数据更方便
					被静态修饰的成员内部类只能访问外部类的静态成员
					内部类被静态修饰后的方法可以是静态方法，可以是非静态方法
					
					成员内部类被静态修饰后的访问方式是
						外部类名.内部类名 对象名 = new 外部类名.内部类名();
				
		2.在局部位置定义的类，被称为局部内部类
			a.可以直接访问外部类的成员
			
			b.在局部位置，可以创建内部类对象，通过对象调用内部类的方法，来使用局部类功能
			
			c.局部内部类访问局部变量的注意事项
				局部内部类访问局部变量必须用final修饰
				原因是：
					局部变量是随着方法的调用而调用，随着调用完毕而消失，而对象是在堆中，不会立即消失，所以要加final修饰局部变量，加入final修饰后，这个变量就是常量
					常量在内存中存的是常量值，所以不会随着变量的消失而读取不到
			
30.匿名内部类
	A：匿名内部类就是内部类的简化写法
	
	B：前提：存在一个类或者是接口，这里的类可以是具体类也可以是接口
	
	C：格式：
		new 类名或者接口名{
			重写方法;
		};			
		
	D：本质是：是一个集成了该类或者实现了该接口的子类匿名对象
	
	E：匿名内部类的方法调用
		用类或者接口接收该子类对象（多态思想）
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
